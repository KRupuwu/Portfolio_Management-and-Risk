# -*- coding: utf-8 -*-
"""Portfolio Value at Risk

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qRz95gLGxI5jQ2ZK_XG_GNoH3OKXcPRZ
"""

import numpy as np
import pandas as pd
import yfinance as yf
from scipy.stats import norm, skew, kurtosis
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.ticker import FuncFormatter
from dataclasses import dataclass
from typing import Tuple, Dict

# ======================================
# VaR Calculation Functions
# ======================================

def historical_var(returns: pd.Series, confidence_level: float = 0.95) -> float:
    """Historical (empirical) 1-day VaR as a *positive* number.
    Uses np.quantile for proper interpolation.

    VaR is returned as a decimal (e.g., 0.025 for 2.5%).
    """
    q = np.quantile(returns, 1 - confidence_level, method="linear")  # typically negative
    return -q

def parametric_var(returns: pd.Series, confidence_level: float = 0.95) -> float:
    """Variance–covariance (normal) 1-day VaR as a *positive* number.
    Uses sample mean and sample std (ddof=1).
    """
    mu = returns.mean()
    sigma = returns.std(ddof=1)
    z = norm.ppf(1 - confidence_level)  # negative at cl=0.95
    return -(mu + z * sigma)

def cornish_fisher_var(returns: pd.Series, confidence_level: float = 0.95) -> float:
    """Cornish–Fisher adjusted VaR to account for skewness and (excess) kurtosis.
    Returns a *positive* decimal VaR.
    """
    mu = returns.mean()
    sigma = returns.std(ddof=1)
    S = skew(returns, bias=False)
    K_ex = kurtosis(returns, fisher=True, bias=False)  # excess kurtosis
    z = norm.ppf(1 - confidence_level)
    # Cornish–Fisher expansion for adjusted quantile
    z_cf = (
        z
        + (1/6) * (z**2 - 1) * S
        + (1/24) * (z**3 - 3*z) * K_ex
        - (1/36) * (2*z**3 - 5*z) * (S**2)
    )
    return -(mu + z_cf * sigma)

def monte_carlo_var_univariate(returns: pd.Series, num_simulations: int = 100_000,
                               confidence_level: float = 0.95, random_state: int | None = 42) -> float:
    """Univariate Normal Monte Carlo VaR on the *portfolio* return series.
    Returns a *positive* decimal VaR.
    """
    rng = np.random.default_rng(random_state)
    mu = returns.mean()
    sigma = returns.std(ddof=1)
    sims = rng.normal(mu, sigma, num_simulations)
    q = np.quantile(sims, 1 - confidence_level, method="linear")
    return -q

def monte_carlo_var_multivariate(asset_returns: pd.DataFrame, weights: np.ndarray,
                                 num_simulations: int = 100_000,
                                 confidence_level: float = 0.95,
                                 random_state: int | None = 42) -> float:
    """Multivariate Normal Monte Carlo VaR using mean vector & covariance matrix of assets.
    Simulates joint asset returns, forms portfolio returns, and computes VaR.
    Returns a *positive* decimal VaR.
    """
    rng = np.random.default_rng(random_state)
    mu_vec = asset_returns.mean().values  # shape (N,)
    cov = asset_returns.cov(ddof=1).values  # shape (N,N)
    sims = rng.multivariate_normal(mean=mu_vec, cov=cov, size=num_simulations)
    port_sims = sims @ weights
    q = np.quantile(port_sims, 1 - confidence_level, method="linear")
    return -q

# ======================================
# Visualization Functions
# ======================================

def visualize_portfolio_performance(portfolio_returns: pd.Series, initial_capital: float,
                                    var_pct_for_band: float, title_suffix: str = "") -> None:
    """Visualizes portfolio value over time with a dynamic VaR band.
    var_pct_for_band: pick which VaR (as decimal) to use for the shaded band.
    """
    sns.set_style("whitegrid")
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = 'Arial'

    cumulative_returns = (1 + portfolio_returns).cumprod()
    portfolio_value_over_time = cumulative_returns * initial_capital
    var_dollar_band = var_pct_for_band * portfolio_value_over_time

    fig, ax = plt.subplots(figsize=(14, 8))
    ax.plot(portfolio_value_over_time.index, portfolio_value_over_time.values, linewidth=2, label='Portfolio Value')

    ax.fill_between(
        portfolio_value_over_time.index,
        portfolio_value_over_time - var_dollar_band,
        portfolio_value_over_time,
        alpha=0.3,
        label=f'{int(100*0.95)}% VaR Zone',
    )

    ax.set_title(f'Portfolio Performance and Value at Risk (VaR){" - " + title_suffix if title_suffix else ""}', fontsize=16, fontweight='bold', pad=20)
    ax.set_ylabel('Portfolio Value ($)', fontsize=12)
    ax.set_xlabel('Date', fontsize=12)
    ax.yaxis.set_major_formatter(FuncFormatter(lambda x, p: f'${x:,.0f}'))
    ax.legend(loc='upper left')
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)

    final_value = portfolio_value_over_time.iloc[-1]
    ax.text(portfolio_value_over_time.index[-1], final_value, f' Final Value: ${final_value:,.2f}',
            va='center', ha='right', fontsize=10, fontweight='bold',
            bbox=dict(boxstyle='round,pad=0.3', fc='yellow', alpha=0.6))

    plt.tight_layout(pad=2.0)
    plt.show()

def visualize_returns_distribution(portfolio_returns: pd.Series,
                                   var_levels: Dict[str, float],
                                   confidence_level: float = 0.95) -> None:
    """Histogram + KDE of daily portfolio returns with VaR markers.
    var_levels: dict mapping label -> VaR decimal (positive numbers).
    """
    sns.set_style("whitegrid")
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = 'Arial'

    fig, ax = plt.subplots(figsize=(12, 7))
    sns.histplot(portfolio_returns, bins=50, kde=True, stat="density", ax=ax, alpha=0.6, label='Daily Returns Distribution')

    for label, v in var_levels.items():
        ax.axvline(x=-v, linestyle='--', linewidth=2, label=f"{label}: {-v:.2%}")

    ax.set_title(f'Daily Returns Distribution with {int(100*confidence_level)}% VaR Levels', fontsize=16, fontweight='bold', pad=20)
    ax.set_xlabel('Daily Returns', fontsize=12)
    ax.set_ylabel('Density', fontsize=12)
    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, p: f'{x:.1%}'))
    ax.legend(loc='upper left')
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)

    plt.tight_layout(pad=2.0)
    plt.show()

# ======================================
# Reporting Helpers
# ======================================

@dataclass
class PortfolioReport:
    per_asset: pd.DataFrame
    portfolio_row: pd.Series


def build_report(asset_returns: pd.DataFrame, portfolio_returns: pd.Series,
                 var_hist: float, var_param: float, var_cf: float,
                 var_mc_uni: float, var_mc_multi: float,
                 initial_capital: float) -> PortfolioReport:
    """Constructs a tidy report with asset stats and portfolio VaRs.
    Returns a PortfolioReport containing a per-asset table and a portfolio summary row.
    """
    per_asset = pd.DataFrame({
        'Mean (daily)': asset_returns.mean(),
        'Std (daily)': asset_returns.std(ddof=1),
        'Skew': asset_returns.apply(lambda s: skew(s, bias=False)),
        'Excess Kurtosis': asset_returns.apply(lambda s: kurtosis(s, fisher=True, bias=False)),
    })

    port_mu = portfolio_returns.mean()
    port_sigma = portfolio_returns.std(ddof=1)

    port_dict = {
        'Mean (daily)': port_mu,
        'Std (daily)': port_sigma,
        'Hist VaR (95%) %': var_hist,
        'Param VaR (95%) %': var_param,
        'Cornish–Fisher VaR (95%) %': var_cf,
        'MC Univariate VaR (95%) %': var_mc_uni,
        'MC Multivariate VaR (95%) %': var_mc_multi,
        'Hist VaR $': var_hist * initial_capital,
        'Param VaR $': var_param * initial_capital,
        'Cornish–Fisher VaR $': var_cf * initial_capital,
        'MC Univariate VaR $': var_mc_uni * initial_capital,
        'MC Multivariate VaR $': var_mc_multi * initial_capital,
    }

    portfolio_row = pd.Series(port_dict, name='PORTFOLIO')
    return PortfolioReport(per_asset=per_asset, portfolio_row=portfolio_row)


def print_summary(report: PortfolioReport, confidence_level: float, initial_capital: float) -> None:
    print("\n--- Portfolio VaR Analysis ---")
    print(f"Initial Portfolio Value: ${initial_capital:,.2f}")
    pr = report.portfolio_row
    print(f"Historical VaR ({int(100*confidence_level)}%): ${pr['Hist VaR $']:,.2f} ({-pr['Hist VaR (95%) %']:.2%})")
    print(f"Parametric VaR ({int(100*confidence_level)}%): ${pr['Param VaR $']:,.2f} ({-pr['Param VaR (95%) %']:.2%})")
    print(f"Cornish–Fisher VaR ({int(100*confidence_level)}%): ${pr['Cornish–Fisher VaR $']:,.2f} ({-pr['Cornish–Fisher VaR (95%) %']:.2%})")
    print(f"MC Univariate VaR ({int(100*confidence_level)}%): ${pr['MC Univariate VaR $']:,.2f} ({-pr['MC Univariate VaR (95%) %']:.2%})")
    print(f"MC Multivariate VaR ({int(100*confidence_level)}%): ${pr['MC Multivariate VaR $']:,.2f} ({-pr['MC Multivariate VaR (95%) %']:.2%})")
    print("\nInterpretation: With the selected confidence level, the portfolio is not expected to lose more than the VaR amount in a single day under the respective model assumptions.")

# ======================================
# Main
# ======================================

if __name__ == "__main__":
    # 1) Inputs
    tickers = ['AAPL', 'NVDA', 'PLTR', 'AMZN', 'AVGO','SOFI', 'UBER', 'HOOD', 'MSTR', 'CRWD', 'ZS', 'IONQ', 'TEM', 'AMD']  # Tech, Financials
    weights = np.array([0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714, 0.0714])     # Equal weights (sum to 1)
    portfolio_value = 5000
    start_date = '2025-01-01'
    end_date = '2025-08-07'
    confidence_level = 0.95

    # 2) Data
    print(f"Fetching historical data for: {', '.join(tickers)}...")
    prices = yf.download(tickers, start=start_date, end=end_date)['Close']

    if prices.empty:
        raise SystemExit("Could not download data. Please check tickers, dates, or network.")

    # 3) Returns
    daily_returns = prices.pct_change().dropna()

    # Ensure alignment and length
    if daily_returns.isna().any().any():
        daily_returns = daily_returns.dropna()

    # Portfolio daily returns
    portfolio_returns = daily_returns @ weights
    portfolio_returns.name = 'Portfolio'

    # 4) VaR calculations (all returned as positive decimals)
    var_hist = historical_var(portfolio_returns, confidence_level)
    var_param = parametric_var(portfolio_returns, confidence_level)
    var_cf = cornish_fisher_var(portfolio_returns, confidence_level)
    var_mc_uni = monte_carlo_var_univariate(portfolio_returns, confidence_level=confidence_level)
    var_mc_multi = monte_carlo_var_multivariate(daily_returns, weights, confidence_level=confidence_level)

    # 5) Report
    report = build_report(
        asset_returns=daily_returns,
        portfolio_returns=portfolio_returns,
        var_hist=var_hist,
        var_param=var_param,
        var_cf=var_cf,
        var_mc_uni=var_mc_uni,
        var_mc_multi=var_mc_multi,
        initial_capital=portfolio_value,
    )

    # Save per-asset table and portfolio row to CSV for convenience
    per_asset_out = report.per_asset.copy()
    per_asset_out.index.name = 'Ticker'
    per_asset_out.to_csv('per_asset_stats.csv')

    report.portfolio_row.to_frame().T.to_csv('portfolio_var_summary.csv', index=True)

    # 6) Print console summary
    print_summary(report, confidence_level, portfolio_value)

    # 7) Visualizations
    var_levels = {
        'Historical VaR': var_hist,
        'Parametric VaR': var_param,
        'Cornish–Fisher VaR': var_cf,
        'MC Univariate VaR': var_mc_uni,
        'MC Multivariate VaR': var_mc_multi,
    }

    # Use multivariate MC for the band by default
    visualize_portfolio_performance(portfolio_returns, portfolio_value, var_pct_for_band=var_mc_multi,
                                    title_suffix=f"{int(100*confidence_level)}% CL")

    visualize_returns_distribution(portfolio_returns, var_levels, confidence_level)

def simulate_paths_normal(portfolio_returns: pd.Series, start_value: float,
                          days_ahead: int = 90, num_sims: int = 10_000,
                          random_state: int | None = 123) -> np.ndarray:
    rng = np.random.default_rng(random_state)
    mu = portfolio_returns.mean()
    sigma = portfolio_returns.std(ddof=1)
    sims = rng.normal(mu, sigma, size=(num_sims, days_ahead))
    end_values = start_value * np.prod(1 + sims, axis=1)
    return end_values

def simulate_paths_bootstrap(portfolio_returns: pd.Series, start_value: float,
                             days_ahead: int = 90, num_sims: int = 10_000,
                             random_state: int | None = 123) -> np.ndarray:
    rng = np.random.default_rng(random_state)
    draws = rng.choice(portfolio_returns.values, size=(num_sims, days_ahead), replace=True)
    end_values = start_value * np.prod(1 + draws, axis=1)
    return end_values

def summarize_forecast(end_values: np.ndarray) -> dict:
    return {
        "mean": float(np.mean(end_values)),
        "median": float(np.median(end_values)),
        "p5": float(np.percentile(end_values, 5)),
        "p95": float(np.percentile(end_values, 95)),
    }

def plot_forecast_distribution(end_values: np.ndarray, title: str) -> None:
    sns.set_style("whitegrid")
    fig, ax = plt.subplots(figsize=(12, 7))
    sns.histplot(end_values, bins=50, kde=True, stat="density", ax=ax, alpha=0.6)
    ax.set_title(title, fontsize=16, fontweight="bold")
    ax.set_xlabel("Portfolio Value ($)")
    ax.set_ylabel("Density")
    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, p: f"${x:,.0f}"))
    plt.tight_layout(pad=2.0)
    plt.show()

# ---- run the forecast ----
# Use last observed portfolio level as today's starting point
cumulative = (1 + portfolio_returns).cumprod()
start_today = portfolio_value * cumulative.iloc[-1]

end_vals_normal = simulate_paths_normal(portfolio_returns, start_value=start_today,
                                        days_ahead=90, num_sims=10_000, random_state=123)
end_vals_boot = simulate_paths_bootstrap(portfolio_returns, start_value=start_today,
                                         days_ahead=90, num_sims=10_000, random_state=123)

normal_summary = summarize_forecast(end_vals_normal)
boot_summary = summarize_forecast(end_vals_boot)

print("\n--- 90-Day Projection (10,000 paths) ---")
print(f"Start (today):             $ {start_today:,.2f}")
print("Normal (i.i.d. normal) returns:")
print(f"  Mean:                     $ {normal_summary['mean']:,.2f}")
print(f"  Median:                   $ {normal_summary['median']:,.2f}")
print(f"  5th–95th percentile:      $ {normal_summary['p5']:,.2f}  —  $ {normal_summary['p95']:,.2f}")
print("Bootstrap (i.i.d. resample) returns:")
print(f"  Mean:                     $ {boot_summary['mean']:,.2f}")
print(f"  Median:                   $ {boot_summary['median']:,.2f}")
print(f"  5th–95th percentile:      $ {boot_summary['p5']:,.2f}  —  $ {boot_summary['p95']:,.2f}")

# Histograms
plot_forecast_distribution(end_vals_normal, "Projected Portfolio Value in 90 Days — Normal Simulation")
plot_forecast_distribution(end_vals_boot, "Projected Portfolio Value in 90 Days — Bootstrap Simulation")